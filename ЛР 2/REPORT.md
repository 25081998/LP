#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Бабичева А. Д. М8О-204Б-17

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|     4.11     |       5-      |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*
Оценка сложности алгоритма (эффективность, непротиворечивость)

## Введение

Существует несколько подходов к решению логических задач, относящихся к методам перебора. Одним из них является метод порождения и проверок. Суть данного метода такова: некоторый предикат множество исходных данных, которые далее обрабатываются другими предикатами на предмет соответствия условию задачи. В случае несоответствия выполняется возврат, подразумевающий генерацию новых исходных данных с дальнейшей их проверкой. В случае соответствия условий программа прекращает вычисления, так как задача считается решенной.

Еще одним подходом к решению логических задач является метод ветвей и границ. Этот подход предполагает отсечение заведомо неправильных решений, что значительно уменьшает количество переборов данных по сравнению с предыдущим методом. В остальном эти методы имеют общюю идею.

Prolog удобен для решения логических задач наличием в нем бэктрэкинга, который позволяет при каждой неудаче совершать откат и продолжать поиск в дереве вариантов. Еще одним достоинством данного языка логического программирования является то, что для описания условий задачи достаточно сформировать ряд предикатов, которые принимают значения ИСТИНА или ЛОЖЬ, что позволяет сразу отсекать неподходящие ветви.

## Задание

1. Воронов, Павлов, Левицкий и Сахаров четыре талантливых молодых человека. Один из них танцор, другой художник, третий певец, четвертый писатель. Воронов и Левицкий сидели в зале консерватории в тот вечер, когда певец дебютировал в сольном концерте. Павлов и писатель вместе позировали художнику. Писатель написал биографическую повесть о Сахарове и собирается написать о Воронове. Воронов никогда не слышал о Левицком. Кто чем занимается?

## Принцип решения

Условия задачи удобно описать предикатами, которые определяют, знакомы ли люди между собой. Важно, что один человек может знать другого, который, в свою очередь, может не знать первого.

```
knows("Воронов", певец).
knows("Левицкий", певец).
knows("Павлов", писатель).
knows("Павлов", художник).
knows(писатель, "Павлов").
knows(художник, "Павлов").
knows(писатель, художник).
knows(художник, писатель).
knows(писатель, "Сахаров").
knows(писатель, "Воронов").
```

Также в условии задачи сказано, что конкретный человек никогда не знал другого, что тоже необходимо отразить на языке предикатов. При этом ложность предыдущих предикатов не будет соответствовать истинности нового.

```
notknows("Воронов", "Левицкий").
```

Само решение будет представлять собой список, содержащий в себе людей и их профессии.

```
A = [man("Воронов", P1), man("Павлов", P2), man("Левицкий", P3), man("Сахаров", P4)],
```

Нахождение решения будет происходить перебором попарно различных профессий. Они будут присваиться конкретному человеку, который не может знать сам себя и не должен одновременно знать и не знать другого человека. Данные предикаты описаны так:

```
knowself(A) :- member(man(X, Y), A), knows(X, Y).
knowself(A) :- member(man(X, Y), A), knows(Y, X).

conflict(A) :- member(man(X, Y), A),
  	member(man(Z, W), A),
  	knows(X, W),
  	notknows(X, Z).
conflict(A) :- member(man(X, Y), A),
  	member(man(Z, W), A),
  	knows(Y, W),
  	notknows(X, Z).
```

Результатом работы программы является:

```
?- solution(Ans).
Ans = [man("Воронов", танцор), man("Павлов", певец), man("Левицкий", писатель), man("Сахаров", художник)]
```

## Выводы

Данная лабораторная работа стала открывающей для меня, именно с нее началось изучение языка и парадигмы логического программирования. Благодаря такому заданию я познакомилась с понятием предиката и его применением в языке Prolog.

Также я открыла для себя встроенную функцию языка member, которая очень помогла мне при решении поставленной задачи.

Еще одним важным аспектом для меня стало понимание того, что иногда порядок выполнения алгоритма во многих случаях (в особенности при решении подобных задач) может значительно уменьшить дерево обхода путем отсечения неверных решений на ранних стадиях проверки условий. Таким образом, при перестановке строчек кода можно получить значительно более эффективную программу.

Помимо всего этого я, конечно же, получила опыт программного решения логических задач.
