# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Бабичева А. Д. М8О-204Б-17

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

После проделанной работы по курсовому проекту я получу много новых знаний при написании реферата, опыт в составлении родословного дерева, получу практические знания при создании парсера, усовершенствую распознаватель естественного языка, описанный в 4 лабораторной работе.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ...
 3. Реализовать предикат проверки/поиска .... 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Свое родословное дерево я составила на рекомендованном портале, далее импортировала его в формат GEDCOM. Мое родословное дерево насчитывает в себе 28 индивидуумов, включая и женщин, и мужчин разных возрастов.

## Конвертация родословного дерева

Для написания парсера я использовала язык C++, так как у меня был опыт работы с ним и в нем есть динамическая структура данных vector, с которой удобно работать при решении данной задачи.

Принципом работы является "путешествие" по файлу с родословной и поиск ключевых структур, таких как INDI, NAME, FAM, HUSB, WIFE, CHIL, UID, F, M, которые обозначают ту или иную степень родства, имя и прочее. При нахождении определенной структуры необходимо последуюущее имя внести в векторы людей, женщин, мужчин и родственников.

Для примера приведу часть кода, которая определяет пол человека:

```
file.open(argv[1]);
    i = 0;
    while (!file.eof()) {
        string s;
        file >> s;
        data.push_back(s);
        if (data[i] == "M") {
            People men1;
            int j = i;
            while (data[j - 1] != "NAME") {
            	j--;
            }
			men1.name = data[j];
            males.push_back(men1);
         }
         else if (data[i] == "F") {
            People men1;
            int j = i;
            while (data[j - 1] != "NAME") {
            	j--;
            }
			men1.name = data[j];
            females.push_back(men1);
         }
         i++;
    }
```

После найденные люди и отношения записываются на языке предикатов в пустой файл.

В итоге получилось так:

```
child("Анна", "Дмитрий").
child("Анна", "Светлана").
child("Максим", "Дмитрий").
child("Максим", "Светлана").
child("Валерий", "Николай").
child("Валерий", "Татьяна").
child("Дмитрий", "Николай").
child("Дмитрий", "Татьяна").
child("Владимир", "Виктор").
child("Владимир", "Антонина").
child("Светлана", "Виктор").
child("Светлана", "Антонина").
child("Виктор", "/Мытарёв/").
child("Виктор", "//").
child("Клавдия", "/Мытарёв/").
child("Клавдия", "//").
child("Мария", "/Мытарёв/").
child("Мария", "//").
child("Валентина", "/Мытарёв/").
child("Валентина", "//").
child("Антонина", "//").
child("Людмила", "//").
child("Тамара", "//").
child("Валентина", "//").
child("Нина", "//").
child("Владимир", "//").
child("Мария", "Валерий").
child("Мария", "//").
child("Валерий", "Валерий").
child("Валерий", "//").
child("Антон", "Владимир").
child("Антон", "//").
child("Татьяна", "Алексей").
child("Татьяна", "Зоя").
child("Виктор", "Алексей").
child("Виктор", "Зоя").
child("Николай", "Борис").
child("Николай", "Татьяна").
child("Юрий", "Борис").
child("Юрий", "Татьяна").

female("Светлана").
female("Анна").
female("Татьяна").
female("Антонина").
female("Клавдия").
female("Мария").
female("Валентина").
female("Людмила").
female("Тамара").
female("Валентина").
female("Нина").
female("Мария").
female("Зоя").
female("Татьяна").

male("Дмитрий").
male("Максим").
male("Николай").
male("Виктор").
male("Владимир").
male("/Мытарёв/").
male("Владимир").
male("Валерий").
male("Валерий").
male("Антон").
male("Алексей").
male("Виктор").
male("Борис").
male("Юрий").
```

## Предикат поиска родственника

Предикат поиска шурина выглядит относительно просто: проверяются родственные связи человека с потенциальным шурином путем перебора людей.

```
brother_in_law(Pers, Bro) :-
	male(Pers),
	child(Ch, Pers),
	child(Ch, Wife),
	female(Wife),
	child(Wife, Grand),
	child(Bro, Grand),
	male(Bro).
```

Запуск программы осуществляется следующим образом:

```
solve(X, B) :- brother_in_law(X, B).
```

Результат работы:

```
?- brother_in_law("Дмитрий", X).
X = "Владимир" .

?- brother_in_law("Валерий", X).
X = "Виктор"

?- brother_in_law("Николай", X).
X = "Виктор" .
```

## Определение степени родства

При определении степени родства мне неизменно помогает предикат move, первым аргументом которого выступает родственная связь. Такой же подход был в 4 лабораторной работе, поэтому я не буду здесь более подробно останавляиваться.

Для определения цепочки родства я использовала предикат relative, внутри которого происходит поиск с итерационным углублением и сохранение пути (подобно работе 3). В зависимости от того, что именно мы хотим сделать с помощью этого предиката (найти цепочку родства или имя конкретного родственника), предикат выполняет работу, определенную через ИЛИ:

```
relative(W, X, Y) :- (findall(Q, move(W, Q, X), Y), !; id_search(X, Y, L), translator(L, W), write('W '), printer(W)).
```

С помощью транслятора мы проверяем степень родства между найденными людьми:

```
translator([H, R], [W]) :- move(W, R, H), !.
translator([H, R|T], TQ) :- 
	translator([R|T], TY), move(W, R, H), 
	append(TY, [W], TQ), !.
```

Предикат printer выполняет красивую печать полученной цепочки:

```
printer([]).
printer([H|T]) :- write(' - '), write(H), delete([H|T], H, T1), printer(T1).
```

Результат работы:

```
?- relative(W, 'Анна', 'Владимир').
W  - daughter - sister
W = [daughter, sister].

?- relative(brother, 'Анна', X).
X = ['Максим'].

?- relative(mother, 'Анна', X).
X = ['Светлана'].

?- relative(W, 'Анна', 'Максим').
W  - sister
W = [sister].

?- relative(W, 'Анна', 'Клавдия').
W  - granddaughter - brother
W = [granddaughter, brother].
```



## Естественно-языковый интерфейс

Решение для данного задания - усовершенствованная модель анализатора из 4 лабораторной работы. Пришлось пересмотреть способ задания вопросов программе, описать множество возможных грамматических структур, учесть использование местоимений при построении запросов. К тому же, был добавлен предикат, позволяющий бесконечно получать запросы от пользователя, пока тот ни захочет выйти из программы, что дает возможность общаться с анализатором не на языке Prolog, а на английском языке:

```
start :-
  	nb_setval(lastName, 'NONE'),
	writeln("Enter your questions:"),
  	repeat, 	
  	readln(Line),
  	((answer(Line), fail);(Line = [exit], !)).
```

Необходимо добавить переменную lastName, в которой будет храниться имя из предыдущего запроса. Это сделано для возможности использования местоимений в запросах.

Для получения информации о количестве родственникой будет использоваться данный предикат:

```
numizmat([], 0).
numizmat([H|T], N) :- delete([H|T], H, T1), numizmat(T1, M), N is M + 1.
```

В данной программе я реализовала ответы на 13 запросов относительно степени родства людей, поэтому приведу в качестве примера лишь два предиката анализатора.

Подсчет количества родственников:

```
%+How many RELATIVE's does PERSON have?
answer([Hw, M, R, _, S, D, P, Hv, '?']) :-
	q_how(Hw),
	q_many(M),
	q_do(D),
	q_have(Hv),
	q_for(S),
	move(R, _, _),
	nb_setval(lastName, P),
	findall(Q, move(R, Q, P), T), !,
	numizmat(T, N),
	write(P), write(" has "), write(N), write(" "), write(R), writeln("s."), !.
```

Ответ на запрос о степени родства с местоимением:

```
%+Who is IS/HER RELATIVE ? 
answer([Who, Is, It, R, '?']) :-
	q_who(Who),
	q_to_be(Is),
	move(R, _, _),
	nb_getval(lastName, X),
	findall(Q, (move(R, Q, X)), T), !,
  	write(It), write(" "), write(R), writeln(" is "), printer(T), !.
```

Результат работы программы:

```
?- start.
Enter your questions:
|: who is Максим for Светлана?
Максим for Светлана is son
|: who is Светлана's daughter?
Светлана's daughter is
Анна
|: is she Анна's mother?
Yes
|: does Анна have grandmother?
Yes
|: who is grandmother for her?
grandmother for her is
Антонина
|: how many husband's does Татьяна have?
Татьяна has 3 husbands.
|: how many grandson's does she have?
she has 3 grandsons.
|: exit
true.
```

## Выводы

Данный курсовой проект не только дал мне новые теоретические знания, но и позволил разобраться в некоторых тонкостях языка Prolog. При описании множества запросов я столкнулась с проблемой крайней важности последовательности предикатов для этих запросов. Таким образом, все предикаты с местоимениями были вынесены перед своими "родителями" с именами, так как иначе анализатор выбирал именно родительские запросы для анализа, ввиду похожей структуры запроса.

Также я попрактиковалась в написании парсера и, соответсвенно, в языке C++.

Это здорово, что одна работа может объединить несколько сфер программирования для решения одной задачи, поэтому это был неплохой опыт.
