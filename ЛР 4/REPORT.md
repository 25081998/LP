#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Бабичева А. Д. М8О-204Б-17

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|     5.11     |      4-       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*
Данная л.р. выполняется с использованием грамматик

## Введение

Одной из важных задач искусственного интеллекта является задача обработки языков. Для решения таких задач необходимо правильно классифицировать ту или иную грамматику, порождающую язык, и, в зависимости от классификации, построить для распознающей машины дерево разбора, которое является основным подходом при обработке языка. Дерево разбора укажет, как именно надо интерпретировать языковые конструкции. 

Дерево разбора может основываться на различных грамматических структурах, зависящих от конкретного языка. Для своей работы я выбрала именно такую реализоцию распознавателя.

Так как построение предложений в языках осуществляется по определенным правилам, не так сложно описать эти правила при помощи языка Prolog, который будет искать соответствия предложений с некоторой описанной структурой.

## Задание

Цель работы: Познакомиться на практике с методами анализа естественно-языковых
текстов в системах логического программирования (Пролог, Mecury), реализовать в
соответствии с вариантом задания несложный фрагмент естественного-языкового
интерфейса к модельной задаче и протестировать его на ряде примеров.
1. Генеалогическое дерево задано фактами вида
```
parent(alexei,tolia).
parent(alexei,volodia).
parent(tolia,tima).
...

```

Написать программу на Прологе, запросы к которой будут выглядеть следующим
образом:
```
Запросы:
?- answer([volodia, brat , toli, ‘?’],X).
?- answer([kto, tolin, brat, ‘?’],X).
?- answer([chei, brat, volodia, ‘?’],X).
Результаты: X=yes, X=volodia, X=tolia.

```

## Принцип решения

Древо:

```
parent(vova, lesha).
parent(vova, roma).
parent(lesha, misha).
parent(roma, kolya).
parent(roma, serega).
parent(kolya, tolya).
parent(kolya, jenya).

```

При решении данной задачи снова важную роль будет играть предикат move, который позволит искать ответы на поставленные вопросы. Первым аргументом будет название родственной связи, остальные аргументы - предполагаемые кандидаты на данную родственную связь между ними:

```
move(brat, X, Y) :- 
 	parent(P, X), 
	parent(P, Y).

move(papa, X, Y) :- parent(X, Y).

move(syn, X, Y) :-  parent(Y, X).

move(ded, X, Y) :- 
	parent(X, Z), 
	parent(Z, Y).

move(praded, X, Y) :-  
	parent(X, W), 
	parent(W, Z), 
	parent(Z, Y).
```

В русском языке есть падежи, которые необходимо обработать. Для этого создается предикат имени, в котором перечисляются все необходимые для данной задачи вариации одного и того же имени:

```
name(vova, vovin, vovy).
name(lesha, leshin, leshi).
name(roma, romin, romy).
name(misha, mishin, mishi).
name(kolya, kolin, koli).
name(serega, seregin, seregi).
name(jenya, jenin, jeni).
name(tolya, tolin, toli).
```

Опишем грамматическую структуру возможных вопросов и сам анализатор:

```
% A brat B?
answer([A, B, C, '?'], X) :-
	(parent(A, _); parent(_, A)),
  	move(B, _, _),
  	name(D, _, C),
  	move(B, A, D), 
	X = yes, !.	

% Kto A brat?
answer([A, B, C, '?'], X) :-
	q_kto(A),
	move(C, _, _),
  	name(D, B, _),
  	(parent(D, _);parent(_, D)),
  	findall(Q, (move(C, Q, D), Q \= D), X),
	!.

% chei brat A?
answer([A, B, C, '?'], X) :-
	q_chei(A),
	move(B, _, _),
  	name(C, _, _),
  	(parent(C, _); parent(_, C)),
  	findall(Q, (move(B, C, Q), Q \= C), X), 
	!.
```

## Результаты

```
?- answer([kto, leshin, papa, '?'], X).
X = [vova].

?- answer([roma, brat, leshi, '?'], Ans).
X = yes.

?- answer([chei, ded, vova, '?'], X).
X = [misha, kolya, serega].
```

## Выводы

Данная лабораторная работа научила меня подходу к анализу естественного языка, что в терминах логического программирования становится уже не таким заоблачным. Именно в этой лабораторной работе пришлось задуматься над тем, как представить родственные отношения с помощью предикатов и как получить ответ на один из возможных вопросов с избежанием путанницы у анализатора.

Prolog позволяет справиться с подобного рода задачами, к тому же - справиться относительно просто. К тому же, модернизация возможностей анализатора сводится к добавлению новых правил, которые будут иметь вид уже описанного шаблона с некоторыми поправками, что, несомненно, удобно.

Благодаря этой работе, мои знания в сфере анализа данных, а конкретно языка, значительно увеличились, и теперь подобные задачи меня больше не пугают.
